<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReddyTalk.ai - Complete Testing Interface</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #667eea;
            margin-bottom: 1rem;
        }

        .header p {
            font-size: 1.2rem;
            color: #666;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .test-section {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 2px solid rgba(102, 126, 234, 0.1);
        }

        .test-section h3 {
            color: #667eea;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.4rem;
        }

        .test-section h3 i {
            font-size: 1.5rem;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #333;
        }

        .control-group input,
        .control-group select,
        .control-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .control-group input:focus,
        .control-group select:focus,
        .control-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 1rem;
            margin-bottom: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .btn.btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .btn.btn-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 1rem;
        }

        .status-connected {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-disconnected {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .status-recording {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .results-area {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 1.5rem;
            margin-top: 1rem;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-entry {
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-left: 3px solid #667eea;
            background: white;
            border-radius: 5px;
        }

        .log-entry.success {
            border-left-color: #10b981;
        }

        .log-entry.error {
            border-left-color: #ef4444;
        }

        .log-entry.warning {
            border-left-color: #f59e0b;
        }

        .log-timestamp {
            color: #666;
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }

        .conversation-flow {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 10px;
        }

        .message.user {
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid #3b82f6;
        }

        .message.assistant {
            background: rgba(16, 185, 129, 0.1);
            border-left: 3px solid #10b981;
        }

        .message-header {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .audio-visualizer {
            height: 60px;
            background: #f8fafc;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 1rem 0;
            border: 1px solid #e5e7eb;
        }

        .visualizer-bar {
            width: 3px;
            height: 20px;
            background: #667eea;
            margin: 0 1px;
            border-radius: 2px;
            transition: height 0.1s;
        }

        .phone-interface {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .phone-btn {
            aspect-ratio: 1;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            background: #f8fafc;
            border: 2px solid #e5e7eb;
        }

        .phone-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .metric-card {
            text-align: center;
            padding: 1rem;
            background: #f8fafc;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .metric-label {
            font-size: 0.8rem;
            color: #666;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .call-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 2rem 0;
        }

        .call-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .call-btn.call {
            background: #10b981;
            color: white;
        }

        .call-btn.hangup {
            background: #ef4444;
            color: white;
        }

        .call-btn:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-robot"></i> ReddyTalk.ai Complete Testing Interface</h1>
            <p>Test every feature of your AI medical receptionist in production</p>
        </div>

        <div class="test-grid">
            <!-- Voice Call Testing -->
            <div class="test-section">
                <h3><i class="fas fa-phone-alt"></i> Voice Call Testing</h3>
                
                <div class="status-indicator" id="voiceStatus">
                    <i class="fas fa-circle"></i>
                    <span>Ready to Call</span>
                </div>

                <div class="control-group">
                    <label>Caller Information</label>
                    <input type="text" id="callerName" placeholder="Your Name" value="John Doe">
                    <input type="tel" id="callerPhone" placeholder="Phone Number" value="555-1234">
                </div>

                <div class="control-group">
                    <label>Test Scenario</label>
                    <select id="testScenario">
                        <option value="appointment">Schedule Appointment</option>
                        <option value="emergency">Emergency Call</option>
                        <option value="insurance">Insurance Query</option>
                        <option value="general">General Information</option>
                        <option value="cancel">Cancel Appointment</option>
                    </select>
                </div>

                <div class="call-controls">
                    <button class="call-btn call" id="startCallBtn" onclick="startVoiceCall()">
                        <i class="fas fa-phone"></i>
                    </button>
                    <button class="call-btn hangup" id="endCallBtn" onclick="endVoiceCall()" disabled>
                        <i class="fas fa-phone-slash"></i>
                    </button>
                </div>

                <button class="btn" onclick="testMicrophone()">
                    <i class="fas fa-microphone"></i> Test Microphone
                </button>

                <div class="audio-visualizer" id="audioVisualizer">
                    <div class="visualizer-bar"></div>
                    <div class="visualizer-bar"></div>
                    <div class="visualizer-bar"></div>
                    <div class="visualizer-bar"></div>
                    <div class="visualizer-bar"></div>
                    <div class="visualizer-bar"></div>
                    <div class="visualizer-bar"></div>
                    <div class="visualizer-bar"></div>
                </div>

                <div class="results-area" id="voiceResults">
                    <div class="log-entry">
                        <div class="log-timestamp">Ready for voice testing</div>
                        <div>Click the green phone button to start a test call with ReddyTalk AI</div>
                    </div>
                </div>
            </div>

            <!-- Live Conversation Testing -->
            <div class="test-section">
                <h3><i class="fas fa-comments"></i> Live Conversation Testing</h3>
                
                <div class="control-group">
                    <label>Session ID</label>
                    <input type="text" id="sessionId" placeholder="Auto-generated" readonly>
                </div>

                <div class="control-group">
                    <label>Test Message</label>
                    <textarea id="testMessage" rows="3" placeholder="Type your test message here...">Hello, I would like to schedule an appointment with Dr. Johnson for next Tuesday at 2 PM.</textarea>
                </div>

                <button class="btn" onclick="startConversation()">
                    <i class="fas fa-play"></i> Start New Conversation
                </button>
                <button class="btn" onclick="sendMessage()">
                    <i class="fas fa-paper-plane"></i> Send Message
                </button>
                <button class="btn btn-danger" onclick="endConversation()">
                    <i class="fas fa-stop"></i> End Conversation
                </button>

                <div class="conversation-flow" id="conversationFlow">
                    <div class="message assistant">
                        <div class="message-header">ReddyTalk AI • Ready</div>
                        <div>Start a conversation to see the AI responses here</div>
                    </div>
                </div>
            </div>

            <!-- Real-time Transcription Testing -->
            <div class="test-section">
                <h3><i class="fas fa-closed-captioning"></i> Real-time Transcription</h3>
                
                <div class="status-indicator" id="transcriptionStatus">
                    <i class="fas fa-circle"></i>
                    <span>Not Recording</span>
                </div>

                <button class="btn" id="recordBtn" onclick="toggleRecording()">
                    <i class="fas fa-microphone"></i> Start Recording
                </button>
                <button class="btn btn-warning" onclick="testSpeechToText()">
                    <i class="fas fa-file-audio"></i> Test with Audio File
                </button>

                <div class="control-group">
                    <label>Confidence Threshold</label>
                    <input type="range" id="confidenceThreshold" min="0" max="1" step="0.1" value="0.8">
                    <span id="confidenceValue">0.8</span>
                </div>

                <div class="results-area" id="transcriptionResults">
                    <div class="log-entry">
                        <div class="log-timestamp">Transcription ready</div>
                        <div>Start recording to see live transcription results</div>
                    </div>
                </div>
            </div>

            <!-- System Health Testing -->
            <div class="test-section">
                <h3><i class="fas fa-heartbeat"></i> System Health & Performance</h3>
                
                <button class="btn" onclick="testSystemHealth()">
                    <i class="fas fa-stethoscope"></i> Check System Health
                </button>
                <button class="btn" onclick="loadSystemMetrics()">
                    <i class="fas fa-chart-line"></i> Load Metrics
                </button>
                <button class="btn btn-warning" onclick="stressTest()">
                    <i class="fas fa-bolt"></i> Stress Test
                </button>

                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="apiLatency">--</div>
                        <div class="metric-label">API Latency (ms)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="aiLatency">--</div>
                        <div class="metric-label">AI Response (ms)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="dbLatency">--</div>
                        <div class="metric-label">DB Query (ms)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="uptime">--</div>
                        <div class="metric-label">Uptime</div>
                    </div>
                </div>

                <div class="results-area" id="healthResults">
                    <div class="log-entry">
                        <div class="log-timestamp">System monitoring ready</div>
                        <div>Click buttons above to test system health and performance</div>
                    </div>
                </div>
            </div>

            <!-- Appointment Scheduling Testing -->
            <div class="test-section">
                <h3><i class="fas fa-calendar-plus"></i> Appointment Scheduling</h3>
                
                <div class="control-group">
                    <label>Patient Name</label>
                    <input type="text" id="patientName" placeholder="Patient Full Name" value="John Doe">
                </div>

                <div class="control-group">
                    <label>Phone Number</label>
                    <input type="tel" id="patientPhone" placeholder="555-1234" value="555-1234">
                </div>

                <div class="control-group">
                    <label>Preferred Doctor</label>
                    <select id="preferredDoctor">
                        <option value="johnson">Dr. Johnson - Cardiology</option>
                        <option value="smith">Dr. Smith - General Practice</option>
                        <option value="brown">Dr. Brown - Dermatology</option>
                        <option value="davis">Dr. Davis - Pediatrics</option>
                        <option value="wilson">Dr. Wilson - Orthopedics</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Preferred Date & Time</label>
                    <input type="datetime-local" id="appointmentDateTime">
                </div>

                <button class="btn" onclick="testAppointmentBooking()">
                    <i class="fas fa-calendar-check"></i> Test Booking
                </button>
                <button class="btn btn-warning" onclick="testAppointmentConflict()">
                    <i class="fas fa-exclamation-triangle"></i> Test Conflict
                </button>
                <button class="btn btn-danger" onclick="testCancellation()">
                    <i class="fas fa-calendar-times"></i> Test Cancellation
                </button>

                <div class="results-area" id="appointmentResults">
                    <div class="log-entry">
                        <div class="log-timestamp">Appointment system ready</div>
                        <div>Test appointment booking, conflicts, and cancellations</div>
                    </div>
                </div>
            </div>

            <!-- WebSocket & Dashboard Testing -->
            <div class="test-section">
                <h3><i class="fas fa-broadcast-tower"></i> WebSocket & Dashboard</h3>
                
                <div class="status-indicator" id="wsStatus">
                    <i class="fas fa-circle"></i>
                    <span>Disconnected</span>
                </div>

                <button class="btn" onclick="connectWebSocket()">
                    <i class="fas fa-plug"></i> Connect WebSocket
                </button>
                <button class="btn btn-warning" onclick="subscribeToChannels()">
                    <i class="fas fa-bell"></i> Subscribe to Updates
                </button>
                <button class="btn btn-success" onclick="openDashboard()">
                    <i class="fas fa-external-link-alt"></i> Open Dashboard
                </button>

                <div class="control-group">
                    <label>Test Broadcast Message</label>
                    <textarea id="broadcastMessage" rows="2" placeholder="Test message for live updates">Test live transcription update</textarea>
                </div>

                <button class="btn" onclick="sendTestBroadcast()">
                    <i class="fas fa-broadcast-tower"></i> Send Test Broadcast
                </button>

                <div class="results-area" id="wsResults">
                    <div class="log-entry">
                        <div class="log-timestamp">WebSocket ready</div>
                        <div>Connect to test real-time dashboard updates</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Full Width Section for Complete Integration Testing -->
        <div class="test-section full-width">
            <h3><i class="fas fa-flask"></i> Complete Integration Testing</h3>
            
            <div class="control-group">
                <label>Full System Test Scenarios</label>
                <select id="integrationScenario">
                    <option value="full_appointment">Complete Appointment Flow (Voice → AI → Booking → Confirmation)</option>
                    <option value="emergency_flow">Emergency Call Handling (Voice → Priority → Transfer)</option>
                    <option value="multi_language">Multi-language Support Testing</option>
                    <option value="concurrent_calls">Concurrent Call Handling</option>
                    <option value="system_recovery">System Recovery Testing</option>
                </select>
            </div>

            <button class="btn btn-success" onclick="runIntegrationTest()">
                <i class="fas fa-play-circle"></i> Run Complete Integration Test
            </button>
            <button class="btn btn-warning" onclick="simulateLoad()">
                <i class="fas fa-users"></i> Simulate Multiple Users
            </button>
            <button class="btn" onclick="exportTestResults()">
                <i class="fas fa-download"></i> Export Test Results
            </button>

            <div class="results-area" id="integrationResults">
                <div class="log-entry">
                    <div class="log-timestamp">Integration testing ready</div>
                    <div>Run complete end-to-end tests of the entire ReddyTalk.ai system</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentSessionId = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let websocket = null;
        let isRecording = false;
        let currentConversation = null;

        // API Configuration
        const API_BASE = window.location.hostname === 'localhost' 
            ? 'http://localhost:8080' 
            : 'https://reddytalk-api.politemushroom-457701ff.eastus.azurecontainerapps.io';

        // Initialize the interface
        document.addEventListener('DOMContentLoaded', function() {
            generateSessionId();
            setupEventListeners();
            testSystemHealth();
            connectWebSocket();
            
            // Set default appointment time to tomorrow at 2 PM
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(14, 0, 0, 0);
            document.getElementById('appointmentDateTime').value = tomorrow.toISOString().slice(0, 16);
        });

        function setupEventListeners() {
            // Confidence threshold slider
            const slider = document.getElementById('confidenceThreshold');
            const display = document.getElementById('confidenceValue');
            slider.addEventListener('input', (e) => {
                display.textContent = e.target.value;
            });
        }

        function generateSessionId() {
            currentSessionId = 'test-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            document.getElementById('sessionId').value = currentSessionId;
        }

        // Voice Call Testing Functions
        async function startVoiceCall() {
            const startBtn = document.getElementById('startCallBtn');
            const endBtn = document.getElementById('endCallBtn');
            const status = document.getElementById('voiceStatus');
            const phoneNumber = document.getElementById('callerPhone').value;
            
            startBtn.disabled = true;
            endBtn.disabled = false;
            
            updateStatus(status, 'status-recording', 'Calling...');
            
            try {
                // Check if we should make a real Twilio call or simulate
                const useRealCalls = confirm(
                    'Make a real phone call using Twilio?\n\n' +
                    'Click OK for real call (requires Twilio setup)\n' +
                    'Click Cancel for simulated test call'
                );
                
                if (useRealCalls) {
                    // Make real Twilio outbound call
                    await makeRealTwilioCall(phoneNumber);
                } else {
                    // Start simulated call with browser audio
                    await startSimulatedCall();
                }
                
            } catch (error) {
                logResult('voiceResults', 'error', 'Failed to start voice call: ' + error.message);
                endVoiceCall();
            }
        }

        async function makeRealTwilioCall(phoneNumber) {
            try {
                logResult('voiceResults', 'info', `Initiating Twilio call to ${phoneNumber}...`);
                
                const response = await fetch(`${API_BASE}/webhooks/twilio/api/call/outbound`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        phoneNumber: phoneNumber,
                        sessionId: currentSessionId,
                        message: 'Hello! This is a test call from ReddyTalk.ai. Please speak to test the AI assistant.'
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    logResult('voiceResults', 'success', `Twilio call initiated: ${result.callSid}`);
                    logResult('voiceResults', 'info', `Calling ${result.to} from ${result.from}`);
                    
                    // Monitor call status
                    monitorTwilioCall(result.callSid);
                    
                    currentConversation = { callSid: result.callSid, type: 'twilio' };
                    updateStatus(document.getElementById('voiceStatus'), 'status-recording', 'Call Active');
                } else {
                    throw new Error(result.error || 'Failed to initiate Twilio call');
                }
                
            } catch (error) {
                if (error.message.includes('404')) {
                    logResult('voiceResults', 'warning', 'Twilio not configured - falling back to simulated call');
                    await startSimulatedCall();
                } else {
                    throw error;
                }
            }
        }

        async function startSimulatedCall() {
            try {
                updateStatus(document.getElementById('voiceStatus'), 'status-recording', 'Simulated Call Active');
                logResult('voiceResults', 'success', 'Started simulated voice call with browser audio');
                
                // Start conversation via API
                const callerInfo = {
                    name: document.getElementById('callerName').value,
                    phone: document.getElementById('callerPhone').value
                };
                
                const response = await fetch(`${API_BASE}/api/conversation/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: currentSessionId,
                        callerInfo: callerInfo,
                        channel: 'voice_browser'
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentConversation = result.conversation;
                    logResult('voiceResults', 'success', 'Connected to AI. Conversation ID: ' + currentConversation.id);
                    
                    // Start audio recording for real voice input
                    await startAudioRecording();
                } else {
                    throw new Error(result.error || 'Failed to start conversation');
                }
                
            } catch (error) {
                throw error;
            }
        }

        async function monitorTwilioCall(callSid) {
            const checkInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/webhooks/twilio/api/call/${callSid}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        const call = result.call;
                        logResult('voiceResults', 'info', `Call status: ${call.status} (Duration: ${call.duration || 0}s)`);
                        
                        if (['completed', 'busy', 'no-answer', 'failed', 'canceled'].includes(call.status)) {
                            clearInterval(checkInterval);
                            logResult('voiceResults', 'success', `Call ended: ${call.status}`);
                            
                            setTimeout(() => {
                                endVoiceCall();
                            }, 2000);
                        }
                    }
                } catch (error) {
                    console.error('Error monitoring call:', error);
                    clearInterval(checkInterval);
                }
            }, 5000); // Check every 5 seconds
            
            // Stop monitoring after 5 minutes
            setTimeout(() => clearInterval(checkInterval), 300000);
        }

        async function endVoiceCall() {
            const startBtn = document.getElementById('startCallBtn');
            const endBtn = document.getElementById('endCallBtn');
            const status = document.getElementById('voiceStatus');
            
            startBtn.disabled = false;
            endBtn.disabled = true;
            
            updateStatus(status, 'status-disconnected', 'Ending Call...');
            
            // Stop browser recording if active
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            
            // Handle Twilio call hangup
            if (currentConversation && currentConversation.type === 'twilio' && currentConversation.callSid) {
                try {
                    logResult('voiceResults', 'info', 'Hanging up Twilio call...');
                    
                    const response = await fetch(`${API_BASE}/webhooks/twilio/api/call/${currentConversation.callSid}/hangup`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reason: 'user_ended' })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        logResult('voiceResults', 'success', 'Twilio call hung up successfully');
                    }
                } catch (error) {
                    logResult('voiceResults', 'error', 'Error hanging up Twilio call: ' + error.message);
                }
            }
            
            // End conversation if it exists
            if (currentConversation && !currentConversation.type) {
                try {
                    const response = await fetch(`${API_BASE}/api/conversation/${currentSessionId}/end`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reason: 'user_ended' })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        logResult('voiceResults', 'success', 'Call ended. Summary: ' + result.summary);
                    }
                } catch (error) {
                    logResult('voiceResults', 'error', 'Error ending call: ' + error.message);
                }
            }
            
            setTimeout(() => {
                updateStatus(status, 'status-connected', 'Ready to Call');
            }, 2000);
            
            generateSessionId();
            currentConversation = null;
        }

        async function startAudioRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    } 
                });
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm'
                });
                
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await processAudioChunk(audioBlob);
                };
                
                // Start recording in chunks
                mediaRecorder.start(3000); // 3-second chunks
                startAudioVisualization(stream);
                
                logResult('voiceResults', 'success', 'Audio recording started. Speak now...');
                
            } catch (error) {
                logResult('voiceResults', 'error', 'Microphone access denied: ' + error.message);
            }
        }

        async function processAudioChunk(audioBlob) {
            try {
                // Convert blob to base64 for API
                const arrayBuffer = await audioBlob.arrayBuffer();
                const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                
                const response = await fetch(`${API_BASE}/api/voice/transcribe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        audioData: base64Audio,
                        sessionId: currentSessionId
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.transcription.trim()) {
                    logResult('voiceResults', 'success', 
                        `You: "${result.transcription}" (${Math.round(result.confidence * 100)}% confidence)`);
                    
                    // The API automatically processes this as a conversation message
                    // We should get the AI response back
                    setTimeout(() => fetchLatestAIResponse(), 1000);
                }
                
            } catch (error) {
                logResult('voiceResults', 'error', 'Audio processing failed: ' + error.message);
            }
        }

        async function fetchLatestAIResponse() {
            try {
                const response = await fetch(`${API_BASE}/api/conversation/${currentSessionId}/history`);
                const result = await response.json();
                
                if (result.success && result.conversation) {
                    const messages = result.conversation.messages || [];
                    const lastMessage = messages[messages.length - 1];
                    
                    if (lastMessage && lastMessage.type === 'assistant') {
                        logResult('voiceResults', 'success', `AI: "${lastMessage.content}"`);
                        
                        // Synthesize speech for AI response
                        await synthesizeAIResponse(lastMessage.content);
                    }
                }
            } catch (error) {
                console.error('Error fetching AI response:', error);
            }
        }

        async function synthesizeAIResponse(text) {
            try {
                const response = await fetch(`${API_BASE}/api/voice/synthesize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });
                
                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audio = new Audio(URL.createObjectURL(audioBlob));
                    audio.play();
                    
                    logResult('voiceResults', 'success', 'Playing AI response...');
                }
            } catch (error) {
                console.error('Speech synthesis failed:', error);
            }
        }

        function startAudioVisualization(stream) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            
            source.connect(analyser);
            analyser.fftSize = 256;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const bars = document.querySelectorAll('.visualizer-bar');
            
            function updateVisualization() {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    analyser.getByteFrequencyData(dataArray);
                    
                    bars.forEach((bar, index) => {
                        const value = dataArray[index * 4] || 0;
                        const height = Math.max(20, (value / 255) * 60);
                        bar.style.height = height + 'px';
                    });
                    
                    requestAnimationFrame(updateVisualization);
                }
            }
            
            updateVisualization();
        }

        async function testMicrophone() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                logResult('voiceResults', 'success', 'Microphone test successful - audio permissions granted');
                
                // Test recording for 2 seconds
                const recorder = new MediaRecorder(stream);
                recorder.start();
                
                setTimeout(() => {
                    recorder.stop();
                    stream.getTracks().forEach(track => track.stop());
                    logResult('voiceResults', 'success', 'Microphone test completed');
                }, 2000);
                
            } catch (error) {
                logResult('voiceResults', 'error', 'Microphone test failed: ' + error.message);
            }
        }

        // Conversation Testing Functions
        async function startConversation() {
            try {
                generateSessionId();
                
                const response = await fetch(`${API_BASE}/api/conversation/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: currentSessionId,
                        callerInfo: {
                            name: document.getElementById('callerName').value || 'Test User',
                            phone: document.getElementById('callerPhone').value || '555-TEST'
                        }
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentConversation = result.conversation;
                    addMessageToFlow('assistant', 'Hello! Thank you for calling ReddyTalk Medical Center. How may I help you today?');
                    logResult('conversationResults', 'success', 'New conversation started: ' + currentSessionId);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                logResult('conversationResults', 'error', 'Failed to start conversation: ' + error.message);
            }
        }

        async function sendMessage() {
            const message = document.getElementById('testMessage').value.trim();
            if (!message || !currentSessionId) {
                alert('Please start a conversation first and enter a message');
                return;
            }
            
            try {
                addMessageToFlow('user', message);
                
                const response = await fetch(`${API_BASE}/api/conversation/${currentSessionId}/message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addMessageToFlow('assistant', result.aiResponse.content);
                    logResult('conversationResults', 'success', 'Message processed successfully');
                    
                    // Clear the input
                    document.getElementById('testMessage').value = '';
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                logResult('conversationResults', 'error', 'Failed to send message: ' + error.message);
            }
        }

        async function endConversation() {
            if (!currentSessionId) {
                alert('No active conversation to end');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/conversation/${currentSessionId}/end`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ reason: 'manual_end' })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addMessageToFlow('system', 'Conversation ended. Summary: ' + result.summary);
                    logResult('conversationResults', 'success', 'Conversation ended successfully');
                    currentConversation = null;
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                logResult('conversationResults', 'error', 'Failed to end conversation: ' + error.message);
            }
        }

        function addMessageToFlow(type, content) {
            const flow = document.getElementById('conversationFlow');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            const sender = type === 'user' ? 'You' : type === 'assistant' ? 'ReddyTalk AI' : 'System';
            
            message.innerHTML = `
                <div class="message-header">${sender} • ${timestamp}</div>
                <div>${content}</div>
            `;
            
            flow.appendChild(message);
            flow.scrollTop = flow.scrollHeight;
        }

        // Transcription Testing
        async function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            const status = document.getElementById('transcriptionStatus');
            
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        await testTranscription(audioBlob);
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    
                    btn.innerHTML = '<i class="fas fa-stop"></i> Stop Recording';
                    updateStatus(status, 'status-recording', 'Recording...');
                    
                } catch (error) {
                    logResult('transcriptionResults', 'error', 'Recording failed: ' + error.message);
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                
                btn.innerHTML = '<i class="fas fa-microphone"></i> Start Recording';
                updateStatus(status, 'status-connected', 'Processing...');
            }
        }

        async function testTranscription(audioBlob) {
            try {
                const arrayBuffer = await audioBlob.arrayBuffer();
                const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                
                const response = await fetch(`${API_BASE}/api/voice/transcribe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ audioData: base64Audio })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const confidence = Math.round(result.confidence * 100);
                    logResult('transcriptionResults', 'success', 
                        `Transcribed: "${result.transcription}" (${confidence}% confidence)`);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                logResult('transcriptionResults', 'error', 'Transcription failed: ' + error.message);
            } finally {
                const status = document.getElementById('transcriptionStatus');
                updateStatus(status, 'status-connected', 'Ready');
            }
        }

        async function testSpeechToText() {
            logResult('transcriptionResults', 'info', 'Testing with sample audio...');
            
            try {
                const response = await fetch(`${API_BASE}/api/test/simple/knowledge`);
                const result = await response.json();
                
                if (result.status === 'success') {
                    logResult('transcriptionResults', 'success', 
                        'Speech-to-Text system is operational and connected to AI');
                    logResult('transcriptionResults', 'success', 'AI Response: ' + result.aiResponse);
                } else {
                    throw new Error(result.message);
                }
            } catch (error) {
                logResult('transcriptionResults', 'error', 'Speech-to-Text test failed: ' + error.message);
            }
        }

        // System Health Testing
        async function testSystemHealth() {
            const startTime = Date.now();
            
            try {
                // Test API health
                const apiResponse = await fetch(`${API_BASE}/health/ready`);
                const apiLatency = Date.now() - startTime;
                document.getElementById('apiLatency').textContent = apiLatency;
                
                const health = await apiResponse.json();
                
                if (health.status === 'ready') {
                    logResult('healthResults', 'success', 'System health check passed');
                    
                    // Update individual metrics
                    if (health.checks) {
                        const aiLatency = health.checks.aiServices?.latency || 0;
                        const dbLatency = health.checks.database?.latency || 0;
                        
                        document.getElementById('aiLatency').textContent = aiLatency;
                        document.getElementById('dbLatency').textContent = dbLatency;
                    }
                } else {
                    logResult('healthResults', 'warning', 'System health issues detected');
                }
                
            } catch (error) {
                logResult('healthResults', 'error', 'Health check failed: ' + error.message);
                document.getElementById('apiLatency').textContent = 'Error';
            }
        }

        async function loadSystemMetrics() {
            try {
                const response = await fetch(`${API_BASE}/metrics`);
                const metrics = await response.json();
                
                document.getElementById('uptime').textContent = 
                    Math.floor(metrics.system.uptime / 1000 / 60) + 'm';
                
                logResult('healthResults', 'success', 'System metrics loaded');
                logResult('healthResults', 'info', `Memory: ${Math.round(metrics.system.memoryUsage.rss / 1024 / 1024)}MB`);
                logResult('healthResults', 'info', `Active connections: ${metrics.webSocket.connections}`);
                
            } catch (error) {
                logResult('healthResults', 'error', 'Failed to load metrics: ' + error.message);
            }
        }

        async function stressTest() {
            logResult('healthResults', 'info', 'Starting stress test...');
            
            const promises = [];
            for (let i = 0; i < 10; i++) {
                promises.push(fetch(`${API_BASE}/api/test/simple`));
            }
            
            try {
                const startTime = Date.now();
                await Promise.all(promises);
                const totalTime = Date.now() - startTime;
                
                logResult('healthResults', 'success', 
                    `Stress test completed: 10 concurrent requests in ${totalTime}ms`);
            } catch (error) {
                logResult('healthResults', 'error', 'Stress test failed: ' + error.message);
            }
        }

        // Appointment Testing
        async function testAppointmentBooking() {
            const appointmentData = {
                patientName: document.getElementById('patientName').value,
                patientPhone: document.getElementById('patientPhone').value,
                preferredDoctor: document.getElementById('preferredDoctor').value,
                appointmentDateTime: document.getElementById('appointmentDateTime').value
            };
            
            // Test via conversation API
            const testMessage = `I would like to schedule an appointment with ${appointmentData.preferredDoctor} on ${new Date(appointmentData.appointmentDateTime).toLocaleDateString()} at ${new Date(appointmentData.appointmentDateTime).toLocaleTimeString()}. My name is ${appointmentData.patientName} and my phone number is ${appointmentData.patientPhone}.`;
            
            try {
                if (!currentConversation) {
                    await startConversation();
                }
                
                document.getElementById('testMessage').value = testMessage;
                await sendMessage();
                
                logResult('appointmentResults', 'success', 'Appointment booking test sent to AI');
            } catch (error) {
                logResult('appointmentResults', 'error', 'Appointment test failed: ' + error.message);
            }
        }

        async function testAppointmentConflict() {
            logResult('appointmentResults', 'warning', 'Testing appointment conflict scenario...');
            
            const conflictMessage = "I need an appointment with Dr. Johnson tomorrow at 2 PM, but I also have another appointment at the same time. Can you help me reschedule?";
            
            try {
                if (!currentConversation) {
                    await startConversation();
                }
                
                document.getElementById('testMessage').value = conflictMessage;
                await sendMessage();
                
            } catch (error) {
                logResult('appointmentResults', 'error', 'Conflict test failed: ' + error.message);
            }
        }

        async function testCancellation() {
            const cancellationMessage = "I need to cancel my appointment with Dr. Smith scheduled for next Tuesday.";
            
            try {
                if (!currentConversation) {
                    await startConversation();
                }
                
                document.getElementById('testMessage').value = cancellationMessage;
                await sendMessage();
                
                logResult('appointmentResults', 'warning', 'Cancellation test sent');
            } catch (error) {
                logResult('appointmentResults', 'error', 'Cancellation test failed: ' + error.message);
            }
        }

        // WebSocket Testing
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host.replace('localhost:3000', 'localhost:8080')}/ws`;
            
            try {
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = () => {
                    updateStatus(document.getElementById('wsStatus'), 'status-connected', 'Connected');
                    logResult('wsResults', 'success', 'WebSocket connected to ' + wsUrl);
                };
                
                websocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    logResult('wsResults', 'info', 'Received: ' + JSON.stringify(data, null, 2));
                };
                
                websocket.onclose = () => {
                    updateStatus(document.getElementById('wsStatus'), 'status-disconnected', 'Disconnected');
                    logResult('wsResults', 'warning', 'WebSocket disconnected');
                };
                
                websocket.onerror = (error) => {
                    logResult('wsResults', 'error', 'WebSocket error: ' + error.message);
                };
                
            } catch (error) {
                logResult('wsResults', 'error', 'Failed to connect WebSocket: ' + error.message);
            }
        }

        function subscribeToChannels() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify({
                    type: 'subscribe',
                    channels: ['live_transcription', 'conversation_updates', 'system_metrics']
                }));
                
                logResult('wsResults', 'success', 'Subscribed to live channels');
            } else {
                logResult('wsResults', 'error', 'WebSocket not connected');
            }
        }

        function sendTestBroadcast() {
            const message = document.getElementById('broadcastMessage').value;
            
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify({
                    type: 'test_broadcast',
                    message: message,
                    sessionId: currentSessionId
                }));
                
                logResult('wsResults', 'success', 'Test broadcast sent');
            } else {
                logResult('wsResults', 'error', 'WebSocket not connected');
            }
        }

        function openDashboard() {
            const dashboardUrl = window.location.origin + '/dashboard';
            window.open(dashboardUrl, '_blank');
            logResult('wsResults', 'success', 'Dashboard opened in new tab');
        }

        // Integration Testing
        async function runIntegrationTest() {
            const scenario = document.getElementById('integrationScenario').value;
            logResult('integrationResults', 'info', `Starting integration test: ${scenario}`);
            
            switch (scenario) {
                case 'full_appointment':
                    await runFullAppointmentTest();
                    break;
                case 'emergency_flow':
                    await runEmergencyFlowTest();
                    break;
                case 'multi_language':
                    await runMultiLanguageTest();
                    break;
                case 'concurrent_calls':
                    await runConcurrentCallsTest();
                    break;
                case 'system_recovery':
                    await runSystemRecoveryTest();
                    break;
            }
        }

        async function runFullAppointmentTest() {
            try {
                // Step 1: Start conversation
                logResult('integrationResults', 'info', '1/5 Starting new conversation...');
                await startConversation();
                
                // Step 2: Send appointment request
                logResult('integrationResults', 'info', '2/5 Sending appointment request...');
                document.getElementById('testMessage').value = 
                    'Hi, I would like to schedule an appointment with Dr. Johnson for next Tuesday at 2 PM. My name is John Doe and my phone is 555-1234.';
                await sendMessage();
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Step 3: Confirm details
                logResult('integrationResults', 'info', '3/5 Confirming appointment details...');
                document.getElementById('testMessage').value = 'Yes, that works for me. Please book it.';
                await sendMessage();
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Step 4: Test system health
                logResult('integrationResults', 'info', '4/5 Checking system health...');
                await testSystemHealth();
                
                // Step 5: End conversation
                logResult('integrationResults', 'info', '5/5 Ending conversation...');
                await endConversation();
                
                logResult('integrationResults', 'success', 'Full appointment flow test completed successfully!');
                
            } catch (error) {
                logResult('integrationResults', 'error', 'Integration test failed: ' + error.message);
            }
        }

        async function runEmergencyFlowTest() {
            try {
                logResult('integrationResults', 'warning', 'Testing emergency call handling...');
                
                await startConversation();
                
                document.getElementById('testMessage').value = 
                    'EMERGENCY! I am having severe chest pains and trouble breathing! I need immediate help!';
                await sendMessage();
                
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                logResult('integrationResults', 'success', 'Emergency flow test completed - check AI response for proper escalation');
                
            } catch (error) {
                logResult('integrationResults', 'error', 'Emergency test failed: ' + error.message);
            }
        }

        async function runConcurrentCallsTest() {
            logResult('integrationResults', 'info', 'Testing concurrent call handling...');
            
            const promises = [];
            for (let i = 0; i < 5; i++) {
                promises.push(simulateCall(i + 1));
            }
            
            try {
                await Promise.all(promises);
                logResult('integrationResults', 'success', 'Concurrent calls test completed - all 5 calls handled');
            } catch (error) {
                logResult('integrationResults', 'error', 'Concurrent calls test failed: ' + error.message);
            }
        }

        async function simulateCall(callNumber) {
            const sessionId = 'concurrent-' + Date.now() + '-' + callNumber;
            
            try {
                const response = await fetch(`${API_BASE}/api/conversation/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: sessionId,
                        callerInfo: { name: `Test Caller ${callNumber}`, phone: `555-000${callNumber}` }
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    logResult('integrationResults', 'info', `Call ${callNumber} connected successfully`);
                }
                
                return result;
            } catch (error) {
                throw new Error(`Call ${callNumber} failed: ${error.message}`);
            }
        }

        function simulateLoad() {
            logResult('integrationResults', 'info', 'Simulating multiple concurrent users...');
            runConcurrentCallsTest();
        }

        function exportTestResults() {
            const results = {
                timestamp: new Date().toISOString(),
                testSummary: 'ReddyTalk.ai Complete System Test Results',
                sections: []
            };
            
            // Collect results from all sections
            const resultAreas = ['voiceResults', 'conversationResults', 'transcriptionResults', 
                               'healthResults', 'appointmentResults', 'wsResults', 'integrationResults'];
            
            resultAreas.forEach(areaId => {
                const area = document.getElementById(areaId);
                if (area) {
                    const entries = Array.from(area.querySelectorAll('.log-entry')).map(entry => ({
                        timestamp: entry.querySelector('.log-timestamp')?.textContent || '',
                        message: entry.textContent.replace(entry.querySelector('.log-timestamp')?.textContent || '', '').trim()
                    }));
                    
                    results.sections.push({
                        section: areaId.replace('Results', ''),
                        entries: entries
                    });
                }
            });
            
            // Download as JSON
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `reddytalk-test-results-${Date.now()}.json`;
            a.click();
            
            logResult('integrationResults', 'success', 'Test results exported successfully');
        }

        // Utility Functions
        function updateStatus(element, className, text) {
            element.className = `status-indicator ${className}`;
            element.querySelector('span').textContent = text;
        }

        function logResult(containerId, type, message) {
            const container = document.getElementById(containerId);
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `
                <div class="log-timestamp">${timestamp}</div>
                <div>${message}</div>
            `;
            
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
            
            // Keep only last 50 entries
            while (container.children.length > 50) {
                container.removeChild(container.firstChild);
            }
        }
    </script>
</body>
</html>